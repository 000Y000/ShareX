<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="$this.Text" xml:space="preserve">
    <value>ShareX - FFmpeg opções</value>
  </data>
  <data name="btnCopyPreview.Text" xml:space="preserve">
    <value>Cópia</value>
  </data>
  <data name="btnDownload.Text" xml:space="preserve">
    <value>Baixar</value>
  </data>
  <data name="btnHelp.Text" xml:space="preserve">
    <value>Ajuda...</value>
  </data>
  <data name="btnRefreshSources.Text" xml:space="preserve">
    <value>Atualização</value>
  </data>
  <data name="btnTest.Text" xml:space="preserve">
    <value>Teste com CMD</value>
  </data>
  <data name="cbCustomCommands.Text" xml:space="preserve">
    <value>Use comandos personalizados</value>
  </data>
  <data name="cbPreset.ToolTip" xml:space="preserve">
    <value>O padrão predefinido é "Médio".
Uma predefinição é uma coleção de opções que irá proporcionar uma certa velocidade de codificação, a taxa de compressão. Uma predefinição mais lento irá fornecer melhor compressão (compressão é qualidade por tamanho do arquivo).
Isto significa que, por exemplo, se você direcionar um determinado tamanho ou taxa de bits constante, você vai conseguir melhor qualidade com uma predefinição mais lento.
Da mesma forma, para codificação de qualidade constante, você simplesmente vai economizar bitrate escolhendo uma predefinição mais lento.</value>
  </data>
  <data name="cbShowError.Text" xml:space="preserve">
    <value>Se a gravação ou codificação falhar então mostrar a janela de erro</value>
  </data>
  <data name="gbCodecs.Text" xml:space="preserve">
    <value>Codecs</value>
  </data>
  <data name="gbCommandLineArgs.Text" xml:space="preserve">
    <value>Argumentos de linha de comando adicionais</value>
  </data>
  <data name="gbCommandLinePreview.Text" xml:space="preserve">
    <value>Visualização de linha de comando</value>
  </data>
  <data name="gbSource.Text" xml:space="preserve">
    <value>Fontes</value>
  </data>
  <data name="lblAACQuality.Text" xml:space="preserve">
    <value>Bitrate:</value>
  </data>
  <data name="lblAudioCodec.Text" xml:space="preserve">
    <value>Codec de áudio:</value>
  </data>
  <data name="lblAudioSource.Text" xml:space="preserve">
    <value>Fonte de áudio:</value>
  </data>
  <data name="lblCodec.Text" xml:space="preserve">
    <value>Codec de vídeo:</value>
  </data>
  <data name="lblExtension.Text" xml:space="preserve">
    <value>Extensão (formato de recipiente):</value>
  </data>
  <data name="lblMP3Quality.Text" xml:space="preserve">
    <value>Qualidade:</value>
  </data>
  <data name="lblPreset.Text" xml:space="preserve">
    <value>Predefinição:</value>
  </data>
  <data name="lblQscale.Text" xml:space="preserve">
    <value>Taxa de bits variável:</value>
  </data>
  <data name="lblVideoSource.Text" xml:space="preserve">
    <value>Fonte de vídeo:</value>
  </data>
  <data name="lblVorbisQuality.Text" xml:space="preserve">
    <value>Qualidade:</value>
  </data>
  <data name="lblVP8Bitrate.Text" xml:space="preserve">
    <value>Taxa de bits variável:</value>
  </data>
  <data name="nudQscale.ToolTip" xml:space="preserve">
    <value>1 sendo a mais alta qualidade/maior filesize e 31, sendo o menor qualidade/menor tamanho do arquivo.</value>
  </data>
  <data name="nudx264CRF.ToolTip" xml:space="preserve">
    <value>Fator de taxa constante (CRF): O intervalo da escala quantizador é 0-51: onde 0 é sem perdas, 23 é padrão e 51 é o pior possível.
Um valor mais baixo é de alta qualidade e uma gama subjetivamente sÃ é 18-28.
Considere 18 para ser visualmente lossless ou quase isso: ele deve ser o mesmo ou quase o mesmo como a entrada, mas não é tecnicamente sem perdas.
O intervalo é exponencial, assim aumentar o valor da CRF + 6 é cerca de metade a taxa de bits enquanto -6 é aproximadamente duas vezes a taxa de bits.
Uso geral é escolher o maior valor CRF que ainda fornece uma qualidade aceitável.
Se a saída parece ser bom e, em seguida, tente um valor mais alto e se parece ruim, em seguida, escolha um valor mais baixo.</value>
  </data>
  <data name="tbAACBitrate.ToolTip" xml:space="preserve">
    <value>O padrão é 128k.</value>
  </data>
  <data name="tbMP3_qscale.ToolTip" xml:space="preserve">
    <value>Intervalo é 0-9, onde um valor mais baixo é de alta qualidade. 0-3 normalmente produzirá resultados transparentes, 4 (padrão) deve ser o próximo transparência perceptiva e 6 produz uma qualidade "aceitável".</value>
  </data>
  <data name="tbVorbis_qscale.ToolTip" xml:space="preserve">
    <value>Intervalo é de 0 – 10, onde 10 é a mais alta qualidade. 3 – 6 é uma boa variedade de tentar. O padrão é 3.</value>
  </data>
</root>